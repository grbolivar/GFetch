class GFetch{constructor(t){this.url=t.replace(/[\/]*$/,"/"),this.t=[],this.s={}}headers(t){let e=this.s,r=Object;return t?(r.entries(r.assign(e,t)).forEach(([t,r])=>null==r?delete e[t]:1),this):e}endpoints(t){let e=this;return t?(e.t=[...new Set(e.t.concat(t))],t.forEach(t=>{e[t.toLowerCase().split(/\W/).map((t,e)=>0==e?t:t.charAt(0).toUpperCase()+t.slice(1)).join("")]=new GFetchEndpoint(t,e)}),e):e.t}}class GFetchError extends Error{constructor(t,...e){super(...e),this.status=t.status,this.statusText=t.statusText,this.response=t}toString(){return this.statusText}}class GFetchEndpoint{constructor(t,e){this.name=t,this.h=e,this.i=e.url+t+"/"}fetch(t){let e=this,r=t.method,s=t.route||"",n=t.params||"",h=t.body,i=t.bodyType||"json";return e.o(r,0),t.headers={...e.h.headers(),...t.headers,"X-Requested-With":"XMLHttpRequest"},"object"==typeof n&&(n="?"+Object.entries(n).filter(([t,e])=>null!=e&&""!==e).map(([t,e])=>(t.match(/[=><!]\s*$/)?t:t+"=")+e).join("&")),"object"==typeof h&&"json"==i?(t.body=JSON.stringify(h),t.headers["Content-Type"]="application/json"):t.body=h,fetch(e.i+s+n,t).then(async t=>{if(!t.ok)throw new GFetchError(t);return e.o(r,t.status||200),t.data=await e.u(t),t}).catch(t=>{throw e.o(r,t.status||599),t})}get(t,e){return this.l("GET",t,e)}post(t,e){return this.p("POST",t,e)}put(t,e){return this.p("PUT",t,e)}patch(t,e){return this.p("PATCH",t,e)}delete(t,e){return this.l("DELETE",t,e)}l(t,e,r){return"object"==typeof e&&(r=e,e=null),this.fetch({method:t,route:e,params:r})}p(t,e,r){return r||(r=e,e=null),this.fetch({method:t,body:r,params:e})}o(t,e){let r=this.h.observer;r&&r({endpoint:this.name,method:t,status:e})}async u(t){let e=null;try{e=await t.clone().json()}catch{try{e=await t.clone().text()}catch(t){}}return e}}