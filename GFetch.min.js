class GFetch{constructor(t){this.url=t.replace(/[\/]*$/,"/");this.t=[];this.s={}}headers(t){let e=this;return t?(Object.entries(Object.assign(e.s,t)).forEach(([t,r])=>r==undefined||r==null?delete e.s[t]:1),e):e.s}endpoints(t){let e=this;return t?(e.t=Array.from(new Set(e.t.concat(t))),t.forEach(t=>{e[t.toLowerCase().split(/\W/).map((t,e)=>e==0?t:t.charAt(0).toUpperCase()+t.slice(1)).join("")]=new GFetchEndpoint(t,e)}),e):e.t}}class GFetchError extends Error{constructor(t,...e){super(...e);this.status=t.status;this.statusText=t.statusText}toString(){return this.statusText}}class GFetchEndpoint{constructor(t,e){this.name=t;this.i=e;this.h=e.url+t+"/"}fetch(t){let e=this,r=t.method,s=t.params||"",n=t.body||null;e.o(r,0);t.headers=Object.assign({"X-Requested-With":"XMLHttpRequest"},e.i.headers(),t.headers||{});if(s&&typeof s=="object"){s="?"+Object.entries(s).map(([t,e])=>t+"="+e).join("&")}if(n&&typeof n=="object"){t.body=JSON.stringify(n);t.headers["Content-Type"]="application/json"}return fetch(e.h+s,t).then(async t=>{if(!t.ok){throw new GFetchError(t)}e.o(r,t.status||200);t.data=await e.u(t);return t}).catch(t=>{e.o(r,t.status||599);throw t})}get(t){return this.l("GET",t)}post(t,e){return this.p("POST",t,e)}put(t,e){return this.p("PUT",t,e)}patch(t,e){return this.p("PATCH",t,e)}delete(t){return this.l("DELETE",t)}l(t,e){return this.fetch({method:t,params:e})}p(t,e,r){if(!r){r=e;e=null}return this.fetch({method:t,body:r,params:e})}o(t,e){let r=this.i.observer;if(r)r({endpoint:this.name,method:t,status:e})}async u(t){let e=null;try{e=await t.clone().json()}catch{try{e=await t.clone().text()}catch(t){}}return e}}