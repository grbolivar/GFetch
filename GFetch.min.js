class GFetch{constructor(t){this.url=t.replace(/[\/]*$/,"/"),this.t=[],this.s={}}headers(t){let e=this.s;return t?(Object.entries(Object.assign(e,t)).forEach(([t,r])=>null==r||null==r?delete e[t]:1),this):e}endpoints(t){let e=this;return t?(e.t=Array.from(new Set(e.t.concat(t))),t.forEach(t=>{e[t.toLowerCase().split(/\W/).map((t,e)=>0==e?t:t.charAt(0).toUpperCase()+t.slice(1)).join("")]=new GFetchEndpoint(t,e)}),e):e.t}}class GFetchError extends Error{constructor(t,...e){super(...e),this.status=t.status,this.statusText=t.statusText,this.response=t}toString(){return this.statusText}}class GFetchEndpoint{constructor(t,e){this.name=t,this.h=e,this.i=e.url+t+"/"}fetch(t){let e=this,r=t.method,s=t.params||"",h=t.body||null;return e.o(r,0),t.headers={...e.h.headers(),...t.headers||{},"X-Requested-With":"XMLHttpRequest"},s&&"object"==typeof s&&(s="?"+Object.entries(s).map(([t,e])=>t+"="+e).join("&")),h&&"object"==typeof h&&(t.body=JSON.stringify(h),t.headers["Content-Type"]="application/json"),fetch(e.i+s,t).then(async t=>{if(!t.ok)throw new GFetchError(t);return e.o(r,t.status||200),t.data=await e.u(t),t}).catch(t=>{throw e.o(r,t.status||599),t})}get(t){return this.l("GET",t)}post(t,e){return this.p("POST",t,e)}put(t,e){return this.p("PUT",t,e)}patch(t,e){return this.p("PATCH",t,e)}delete(t){return this.l("DELETE",t)}l(t,e){return this.fetch({method:t,params:e})}p(t,e,r){return r||(r=e,e=null),this.fetch({method:t,body:r,params:e})}o(t,e){let r=this.h.observer;r&&r({endpoint:this.name,method:t,status:e})}async u(t){let e=null;try{e=await t.clone().json()}catch{try{e=await t.clone().text()}catch(t){}}return e}}