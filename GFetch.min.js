class GFetch{constructor(t,e){this.url=t.replace(/[\/]*$/,"/");this.observer=e;this.t=[];this.s={}}headers(t){let e=this;return t?(Object.entries(Object.assign(e.s,t)).forEach(([t,s])=>s==undefined||s==null?delete e.s[t]:1),e):e.s}endpoints(t){let e=this;return t?(e.t=Array.from(new Set(e.t.concat(t))),t.forEach(t=>{if(e[t])return;let s=t.toLowerCase().split(/\W/).map((t,e)=>e==0?t:t.charAt(0).toUpperCase()+t.slice(1)).join("");e[s]=new GFetchEndpoint(t,e)}),e):e.t}}class GFetchEndpoint{constructor(t,e){this.name=t;this.i=e;this.h=e.url+t+"/"}fetch(t){let e=this,s=t.method,r=t.params||"",i=t.body||null;e.u(s,"SENT");t.headers=Object.assign({"X-Requested-With":"XMLHttpRequest"},e.i.headers(),t.headers||{});if(r&&typeof r=="object"){r="?"+Object.entries(r).map(([t,e])=>t+"="+e).join("&")}if(i&&typeof i=="object"){t.body=JSON.stringify(i);t.headers["Content-Type"]="application/json"}return fetch(e.h+r,t).then(async t=>(e.u(s,"OK"),t.data=await e.o(t),t)).catch(t=>{e.u(s,"FAIL");throw t})}get(t){return this.l("GET",t)}post(t,e){return this.p("POST",t,e)}put(t,e){return this.p("PUT",t,e)}patch(t,e){return this.p("PATCH",t,e)}delete(t){return this.l("DELETE",t)}l(t,e){return this.fetch({method:t,params:e})}p(t,e,s){if(!s){s=e;e=null}return this.fetch({method:t,body:s,params:e})}u(t,e){let s=this.i.observer;if(s)s({endpoint:this.name,method:t,status:e})}async o(t){let e=null;try{e=await t.clone().json()}catch{try{e=await t.clone().text()}catch(t){}}return e}}